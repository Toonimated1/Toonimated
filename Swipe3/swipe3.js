(function (cjs, an) {

var p; // shortcut to reference prototypes
var lib={};var ss={};var img={};
lib.ssMetadata = [
		{name:"swipe3_atlas_1", frames: [[0,0,470,470]]}
];


(lib.AnMovieClip = function(){
	this.actionFrames = [];
	this.ignorePause = false;
	this.gotoAndPlay = function(positionOrLabel){
		cjs.MovieClip.prototype.gotoAndPlay.call(this,positionOrLabel);
	}
	this.play = function(){
		cjs.MovieClip.prototype.play.call(this);
	}
	this.gotoAndStop = function(positionOrLabel){
		cjs.MovieClip.prototype.gotoAndStop.call(this,positionOrLabel);
	}
	this.stop = function(){
		cjs.MovieClip.prototype.stop.call(this);
	}
}).prototype = p = new cjs.MovieClip();
// symbols:



(lib.Bitmap1 = function() {
	this.initialize(ss["swipe3_atlas_1"]);
	this.gotoAndStop(0);
}).prototype = p = new cjs.Sprite();
// helper functions:

function mc_symbol_clone() {
	var clone = this._cloneProps(new this.constructor(this.mode, this.startPosition, this.loop, this.reversed));
	clone.gotoAndStop(this.currentFrame);
	clone.paused = this.paused;
	clone.framerate = this.framerate;
	return clone;
}

function getMCSymbolPrototype(symbol, nominalBounds, frameBounds) {
	var prototype = cjs.extend(symbol, cjs.MovieClip);
	prototype.clone = mc_symbol_clone;
	prototype.nominalBounds = nominalBounds;
	prototype.frameBounds = frameBounds;
	return prototype;
	}


(lib.Symbol5 = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_1
	this.shape = new cjs.Shape();
	this.shape.graphics.f().s("rgba(0,0,0,0)").ss(1,1,1).p("AAAlmQCVAABpBpQBpBpAACUQAACVhpBpQhpBpiVAAQiTAAhqhpQhphpAAiVQAAiUBphpQBqhpCTAAg");

	this.shape_1 = new cjs.Shape();
	this.shape_1.graphics.f("#000000").s().p("Aj9D+QhphpAAiVQAAiTBphqQBphpCUAAQCVAABpBpQBpBqAACTQAACVhpBpQhpBpiVAAQiUAAhphpg");

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.shape_1},{t:this.shape}]}).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.Symbol5, new cjs.Rectangle(-36.9,-36.9,73.8,73.8), null);


(lib.Symbol3 = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_1
	this.shape = new cjs.Shape();
	this.shape.graphics.lf(["#00CBFF","#6CD6FF"],[0,1],0,-32.4,0,104.3).s().p("AtST3QjhAAihiSQigiSAAjOIAA4JQAAjOCgiSQChiSDhAAIakAAQDjAACgCSQCgCSAADOIAAYJQAADOigCSQigCSjjAAg");
	this.shape.setTransform(0,136.5,1,1,0,0,0,0,136.5);

	this.timeline.addTween(cjs.Tween.get(this.shape).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.Symbol3, new cjs.Rectangle(-139.7,-127,279.4,254.1), null);


(lib.Symbol2 = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_1
	this.shape = new cjs.Shape();
	this.shape.graphics.lf(["#00CBFF","#6CD6FF"],[0,1],0,-32.4,0,104.3).s().p("AtST3QjhAAihiSQigiSAAjOIAA4JQAAjOCgiSQChiSDhAAIakAAQDjAACgCSQCgCSAADOIAAYJQAADOigCSQigCSjjAAg");
	this.shape.setTransform(0,136.5,1,1,0,0,0,0,136.5);

	this.timeline.addTween(cjs.Tween.get(this.shape).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.Symbol2, new cjs.Rectangle(-139.7,-127,279.4,254.1), null);


(lib.Symbol1 = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_1
	this.shape = new cjs.Shape();
	this.shape.graphics.lf(["#006AFF","#00B9FF"],[0,1],0,-38.6,0,125.8).s().p("AuQXcQjzAAisisQisisAAjzIAA8hQAAjzCsisQCsisDzAAIchAAQDzAACsCsQCsCsAADzIAAchQAADzisCsQisCsjzAAg");

	this.timeline.addTween(cjs.Tween.get(this.shape).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.Symbol1, new cjs.Rectangle(-150,-150,300,300), null);


(lib.dithering = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_1
	this.shape = new cjs.Shape();
	var sprImg_shape = cjs.SpriteSheetUtils.extractFrame(ss["swipe3_atlas_1"],0);
	sprImg_shape.onload = function(){
		this.shape.graphics.bf(sprImg_shape, null, new cjs.Matrix2D(5.825,0,0,5.825,-1920.5,-1873.1)).s().p("EksEkkrMJMOAAAMAL7JDDMpYJAGUg")
	}.bind(this);
	this.shape.setTransform(1920.4875,1873.15);

	this.timeline.addTween(cjs.Tween.get(this.shape).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.dithering, new cjs.Rectangle(0,0,3841,3746.3), null);


(lib.Symbol4 = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_1
	this.instance = new lib.Symbol1();

	this.timeline.addTween(cjs.Tween.get(this.instance).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.Symbol4, new cjs.Rectangle(-150,-150,300,300), null);


(lib.BlockYellowBLOCKER = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_3
	this.shape = new cjs.Shape();
	this.shape.graphics.f("#FF9000").s().p("AKpNKIE3k4IBIBIIk3E4gAwnJaIBIhIIE4E4IhIBIgAKptJIBIhIIE3E4IhIBIgAwnpZIE4k4IBIBIIk4E4g");
	this.shape.setTransform(153.15,125.375);

	this.timeline.addTween(cjs.Tween.get(this.shape).wait(1));

	// Layer_1
	this.instance = new lib.Symbol5();
	this.instance.setTransform(65.95,198.15);
	this.instance.alpha = 0.6484;

	this.instance_1 = new lib.Symbol5();
	this.instance_1.setTransform(65.95,53.2);
	this.instance_1.alpha = 0.6484;

	this.instance_2 = new lib.Symbol5();
	this.instance_2.setTransform(239.4,198.15);
	this.instance_2.alpha = 0.6484;

	this.instance_3 = new lib.Symbol5();
	this.instance_3.setTransform(239.4,53.2);
	this.instance_3.alpha = 0.6484;

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_3},{t:this.instance_2},{t:this.instance_1},{t:this.instance}]}).wait(1));

	// Layer_2
	this.instance_4 = new lib.Symbol2();
	this.instance_4.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance_4.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-63, 0, 69, -134))];
	this.instance_4.cache(-142,-129,283,258);

	this.instance_5 = new lib.Symbol1();
	this.instance_5.setTransform(149.95,150);
	this.instance_5.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_5.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-100, 0, 28, -144))];
	this.instance_5.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_5},{t:this.instance_4}]}).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockYellowBLOCKER, new cjs.Rectangle(-2,0,307,317), null);


(lib.BlockYellow = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_2
	this.instance = new lib.Symbol2();
	this.instance.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-63, 0, 89, -135))];
	this.instance.cache(-142,-129,283,258);

	this.instance_1 = new lib.Symbol1();
	this.instance_1.setTransform(149.95,150);
	this.instance_1.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_1.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-100, 0, 28, -144))];
	this.instance_1.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_1},{t:this.instance}]}).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockYellow, new cjs.Rectangle(-2,0,307,317), null);


(lib.BlockRedBLOCKER = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_1
	this.shape = new cjs.Shape();
	this.shape.graphics.f("#FF0F00").s().p("AKpNKIE3k4IBIBIIk3E4gAwnJaIBIhIIE4E4IhIBIgAKptJIBIhIIE3E4IhIBIgAwnpZIE4k4IBIBIIk4E4g");
	this.shape.setTransform(153.15,125.375);

	this.timeline.addTween(cjs.Tween.get(this.shape).wait(1));

	// Layer_3
	this.instance = new lib.Symbol5();
	this.instance.setTransform(65.95,198.15);
	this.instance.alpha = 0.6484;

	this.instance_1 = new lib.Symbol5();
	this.instance_1.setTransform(65.95,53.2);
	this.instance_1.alpha = 0.6484;

	this.instance_2 = new lib.Symbol5();
	this.instance_2.setTransform(239.4,198.15);
	this.instance_2.alpha = 0.6484;

	this.instance_3 = new lib.Symbol5();
	this.instance_3.setTransform(239.4,53.2);
	this.instance_3.alpha = 0.6484;

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_3},{t:this.instance_2},{t:this.instance_1},{t:this.instance}]}).wait(1));

	// Layer_2
	this.instance_4 = new lib.Symbol2();
	this.instance_4.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance_4.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-43, 0, 18, 171))];
	this.instance_4.cache(-142,-129,283,258);

	this.instance_5 = new lib.Symbol1();
	this.instance_5.setTransform(149.95,150);
	this.instance_5.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_5.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-89, -59, 19, 168))];
	this.instance_5.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_5},{t:this.instance_4}]}).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockRedBLOCKER, new cjs.Rectangle(-2,0,307,317), null);


(lib.BlockRed = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_2
	this.instance = new lib.Symbol2();
	this.instance.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-43, 0, 21, 171))];
	this.instance.cache(-142,-129,283,258);

	this.instance_1 = new lib.Symbol1();
	this.instance_1.setTransform(149.95,150);
	this.instance_1.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_1.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-89, -59, 36, 168))];
	this.instance_1.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_1},{t:this.instance}]}).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockRed, new cjs.Rectangle(-2,0,307,317), null);


(lib.BlockGreyBLOCKER = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_4
	this.shape = new cjs.Shape();
	this.shape.graphics.f("#999999").s().p("AKpNKIE3k4IBIBIIk3E4gAwnJaIBIhIIE4E4IhIBIgAKptJIBIhIIE3E4IhIBIgAwnpZIE4k4IBIBIIk4E4g");
	this.shape.setTransform(153.15,125.375);

	this.timeline.addTween(cjs.Tween.get(this.shape).wait(1));

	// Layer_3
	this.instance = new lib.Symbol5();
	this.instance.setTransform(65.95,198.15);
	this.instance.alpha = 0.6484;

	this.instance_1 = new lib.Symbol5();
	this.instance_1.setTransform(65.95,53.2);
	this.instance_1.alpha = 0.6484;

	this.instance_2 = new lib.Symbol5();
	this.instance_2.setTransform(239.4,198.15);
	this.instance_2.alpha = 0.6484;

	this.instance_3 = new lib.Symbol5();
	this.instance_3.setTransform(239.4,53.2);
	this.instance_3.alpha = 0.6484;

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_3},{t:this.instance_2},{t:this.instance_1},{t:this.instance}]}).wait(1));

	// Layer_2
	this.instance_4 = new lib.Symbol2();
	this.instance_4.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance_4.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(25, 0, -100, -143))];
	this.instance_4.cache(-142,-129,283,258);

	this.instance_5 = new lib.Symbol1();
	this.instance_5.setTransform(149.95,150);
	this.instance_5.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_5.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-2, 0, -100, -172))];
	this.instance_5.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_5},{t:this.instance_4}]}).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockGreyBLOCKER, new cjs.Rectangle(-2,0,307,317), null);


(lib.BlockGrey = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_2
	this.instance = new lib.Symbol2();
	this.instance.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(25, 0, -100, -143))];
	this.instance.cache(-142,-129,283,258);

	this.instance_1 = new lib.Symbol1();
	this.instance_1.setTransform(149.95,150);
	this.instance_1.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_1.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-2, 0, -100, -172))];
	this.instance_1.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_1},{t:this.instance}]}).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockGrey, new cjs.Rectangle(-2,0,307,317), null);


(lib.BlockBlueBLOCKER = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_2
	this.shape = new cjs.Shape();
	this.shape.graphics.f("#00F7FF").s().p("AKpNKIE3k4IBIBIIk3E4gAwnJaIBIhIIE4E4IhIBIgAKptJIBIhIIE3E4IhIBIgAwnpZIE4k4IBIBIIk4E4g");
	this.shape.setTransform(153.15,125.375);

	this.timeline.addTween(cjs.Tween.get(this.shape).wait(1));

	// Layer_1
	this.instance = new lib.Symbol5();
	this.instance.setTransform(65.95,198.15);
	this.instance.alpha = 0.6484;

	this.instance_1 = new lib.Symbol5();
	this.instance_1.setTransform(65.95,53.2);
	this.instance_1.alpha = 0.6484;

	this.instance_2 = new lib.Symbol5();
	this.instance_2.setTransform(239.4,198.15);
	this.instance_2.alpha = 0.6484;

	this.instance_3 = new lib.Symbol5();
	this.instance_3.setTransform(239.4,53.2);
	this.instance_3.alpha = 0.6484;

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_3},{t:this.instance_2},{t:this.instance_1},{t:this.instance}]}).wait(1));

	// Layer_5
	this.instance_4 = new lib.Symbol3();
	this.instance_4.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance_4.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-28, 0, 39, 0))];
	this.instance_4.cache(-142,-129,283,258);

	this.timeline.addTween(cjs.Tween.get(this.instance_4).wait(1));

	// Layer_4
	this.instance_5 = new lib.Symbol4();
	this.instance_5.setTransform(149.95,150);
	this.instance_5.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_5.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-73, 0, 9, 0))];
	this.instance_5.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get(this.instance_5).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockBlueBLOCKER, new cjs.Rectangle(-2,0,307,317), null);


(lib.BlockBlue = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_5_copy (mask)
	var mask = new cjs.Shape();
	mask._off = true;
	mask.graphics.p("AtST3QjhAAihiSQigiSAAjOIAA4JQAAjOCgiSQChiSDhAAIakAAQDjAACgCSQCgCSAADOIAAYJQAADOigCSQigCSjjAAg");
	mask.setTransform(149.95,132.725);

	// Layer_5
	this.instance = new lib.Symbol3();
	this.instance.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance.cache(-142,-129,283,258);

	this.timeline.addTween(cjs.Tween.get(this.instance).wait(1));

	// Layer_4
	this.instance_1 = new lib.Symbol4();
	this.instance_1.setTransform(149.95,150);
	this.instance_1.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_1.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-73, 0, 5, 0))];
	this.instance_1.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get(this.instance_1).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockBlue, new cjs.Rectangle(-2,0,307,317), null);


(lib.BlockBlackBLOCKER = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_4
	this.shape = new cjs.Shape();
	this.shape.graphics.f("#666666").s().p("AKpNKIE3k4IBIBIIk3E4gAwnJaIBIhIIE4E4IhIBIgAKptJIBIhIIE3E4IhIBIgAwnpZIE4k4IBIBIIk4E4g");
	this.shape.setTransform(153.15,125.375);

	this.timeline.addTween(cjs.Tween.get(this.shape).wait(1));

	// Layer_3
	this.instance = new lib.Symbol5();
	this.instance.setTransform(65.95,198.15);
	this.instance.alpha = 0.6484;

	this.instance_1 = new lib.Symbol5();
	this.instance_1.setTransform(65.95,53.2);
	this.instance_1.alpha = 0.6484;

	this.instance_2 = new lib.Symbol5();
	this.instance_2.setTransform(239.4,198.15);
	this.instance_2.alpha = 0.6484;

	this.instance_3 = new lib.Symbol5();
	this.instance_3.setTransform(239.4,53.2);
	this.instance_3.alpha = 0.6484;

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_3},{t:this.instance_2},{t:this.instance_1},{t:this.instance}]}).wait(1));

	// Layer_2
	this.instance_4 = new lib.Symbol2();
	this.instance_4.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance_4.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-100, 0, -100, -143))];
	this.instance_4.cache(-142,-129,283,258);

	this.instance_5 = new lib.Symbol1();
	this.instance_5.setTransform(149.95,150);
	this.instance_5.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_5.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-83, 0, -100, -172))];
	this.instance_5.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_5},{t:this.instance_4}]}).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockBlackBLOCKER, new cjs.Rectangle(-2,0,307,317), null);


(lib.BlockBlack = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	// Layer_2
	this.instance = new lib.Symbol2();
	this.instance.setTransform(149.95,137.4,1,1,0,0,0,0,4.7);
	this.instance.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-100, 0, -100, -143))];
	this.instance.cache(-142,-129,283,258);

	this.instance_1 = new lib.Symbol1();
	this.instance_1.setTransform(149.95,150);
	this.instance_1.shadow = new cjs.Shadow("rgba(0,0,0,0.247)",0,11,0);
	this.instance_1.filters = [new cjs.ColorMatrixFilter(new cjs.ColorMatrix(-83, 0, -100, -172))];
	this.instance_1.cache(-152,-152,304,304);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.instance_1},{t:this.instance}]}).wait(1));

	this._renderFirstFrame();

}).prototype = getMCSymbolPrototype(lib.BlockBlack, new cjs.Rectangle(-2,0,307,317), null);


// stage content:
(lib.swipe3_3 = function(mode,startPosition,loop,reversed) {
if (loop == null) { loop = true; }
if (reversed == null) { reversed = false; }
	var props = new Object();
	props.mode = mode;
	props.startPosition = startPosition;
	props.labels = {};
	props.loop = loop;
	props.reversed = reversed;
	cjs.MovieClip.apply(this,[props]);

	this.actionFrames = [0];
	this.isSingleFrame = false;
	// timeline functions:
	this.frame_0 = function() {
		if(this.isSingleFrame) {
			return;
		}
		if(this.totalFrames == 1) {
			this.isSingleFrame = true;
		}
		/* Global game configuration and variables */
		var playableRows = 4, playableCols = 4;
		var gridMargin = 1; // Border margin (cells) around the playable area
		var boardRows = playableRows + 2; // e.g., 4+2 = 6
		var boardCols = playableCols + 2; // e.g., 4+2 = 6
		var cellSize = 300;   // Each cell is 300x300 pixels (logical size)
		var scoreOffset = 100; // Vertical offset (space for the score)
		
		var stage, scoreText;
		var gameBoard = [];   // 2D array for the logical board state
		var score = 0;        // Current score
		var animating = false; // Disable input during animations
		
		// --- NEW: High Score Global Variables ---
		var topScore = 30000;      // Default top score is 30,000
		var topScoreText;          // Will hold the high score display
		
		// Global array for colors that should be cleared from the board
		var clearColors = [];
		// NEW: Flag to indicate a 4‑in‑a‑row (super clear) event
		var globalClearTriggered = false;
		
		// ----- Retro Dithering Global Variables -----
		var retroWidth = 400;
		var retroHeight = 0;
		var offCanvas = document.createElement("canvas");
		var offCtx = offCanvas.getContext("2d");
		
		// Create a 32-color palette (2 bits for R, 1 bit for G, 2 bits for B)
		var palette32 = [];
		for (var rBits = 0; rBits < 4; rBits++) {
		  for (var gBits = 0; gBits < 2; gBits++) {
		    for (var bBits = 0; bBits < 4; bBits++) {
		      var rVal = Math.round((rBits / 3) * 255);
		      var gVal = Math.round((gBits / 1) * 255);
		      var bVal = Math.round((bBits / 3) * 255);
		      palette32.push([rVal, gVal, bVal]);
		    }
		  }
		}
		
		// 8×8 Bayer matrix (values 0 to 63)
		var bayer8x8 = [
		  [  0, 32,  8, 40,  2, 34, 10, 42 ],
		  [ 48, 16, 56, 24, 50, 18, 58, 26 ],
		  [ 12, 44,  4, 36, 14, 46,  6, 38 ],
		  [ 60, 28, 52, 20, 62, 30, 54, 22 ],
		  [  3, 35, 11, 43,  1, 33,  9, 41 ],
		  [ 51, 19, 59, 27, 49, 17, 57, 25 ],
		  [ 15, 47,  7, 39, 13, 45,  5, 37 ],
		  [ 63, 31, 55, 23, 61, 29, 53, 21 ]
		];
		
		// Utility: clamp a value between mn and mx
		function clamp(v, mn, mx) {
		  return (v < mn) ? mn : (v > mx ? mx : v);
		}
		
		function findClosestPaletteColor(r, g, b) {
		  var bestDist = Infinity;
		  var bestColor = [0, 0, 0];
		  for (var i = 0; i < palette32.length; i++) {
		    var pr = palette32[i][0], pg = palette32[i][1], pb = palette32[i][2];
		    var dr = r - pr, dg = g - pg, db = b - pb;
		    var dist = dr * dr + dg * dg + db * db;
		    if (dist < bestDist) {
		      bestDist = dist;
		      bestColor = palette32[i];
		    }
		  }
		  return bestColor;
		}
		
		// Dithering function
		function applyBayer8x8_32color() {
		  var canvas = document.getElementById("canvas");
		  var mainCtx = canvas.getContext("2d");
		
		  retroHeight = Math.floor(canvas.height * (retroWidth / canvas.width));
		  offCanvas.width = retroWidth;
		  offCanvas.height = retroHeight;
		  
		  offCtx.imageSmoothingEnabled = false;
		  offCtx.clearRect(0, 0, retroWidth, retroHeight);
		  offCtx.drawImage(canvas, 0, 0, retroWidth, retroHeight);
		  
		  var imageData = offCtx.getImageData(0, 0, retroWidth, retroHeight);
		  var data = imageData.data;
		  for (var i = 0; i < data.length; i += 4) {
		    var r = data[i], g = data[i + 1], b = data[i + 2];
		    var index = i / 4;
		    var x = index % retroWidth;
		    var y = Math.floor(index / retroWidth);
		    var threshold = bayer8x8[y % 8][x % 8];
		    var offset = threshold - 31.5;
		    var scaled = offset * (255 / 63) * 0.5;
		    var r2 = clamp(r + scaled, 0, 255);
		    var g2 = clamp(g + scaled, 0, 255);
		    var b2 = clamp(b + scaled, 0, 255);
		    var newColor = findClosestPaletteColor(r2, g2, b2);
		    data[i] = newColor[0];
		    data[i + 1] = newColor[1];
		    data[i + 2] = newColor[2];
		  }
		  offCtx.putImageData(imageData, 0, 0);
		  
		  mainCtx.imageSmoothingEnabled = false;
		  mainCtx.clearRect(0, 0, canvas.width, canvas.height);
		  mainCtx.drawImage(offCanvas, 0, 0, canvas.width, canvas.height);
		}
		
		/* Event interception for mobile and wheel events */
		(function interceptEvents() {
		  const eventsToIntercept = ['touchstart', 'touchmove', 'touchend', 'wheel'];
		  const container = document.getElementById('iframe-container');
		  if (container) {
		    eventsToIntercept.forEach(evtType => {
		      container.addEventListener(evtType, function(event) {
		        event.preventDefault();
		        event.stopPropagation();
		      }, { passive: false });
		    });
		  }
		})();
		
		/* Helper: Check if board is cleared (all cells empty) */
		function boardCleared() {
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      if (gameBoard[i][j] != null) return false;
		    }
		  }
		  return true;
		}
		
		/* Helper functions to check board state */
		function boardIsFull() {
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      if (gameBoard[i][j] == null) return false;
		    }
		  }
		  return true;
		}
		
		function possibleMatchExists() {
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    var count = 1;
		    for (var j = gridMargin + 1; j < gridMargin + playableCols; j++) {
		      if (gameBoard[i][j] && gameBoard[i][j-1] && gameBoard[i][j].color === gameBoard[i][j-1].color) {
		        count++;
		        if (count >= 3) return true;
		      } else {
		        count = 1;
		      }
		    }
		  }
		  for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		    var count = 1;
		    for (var i = gridMargin + 1; i < gridMargin + playableRows; i++) {
		      if (gameBoard[i][j] && gameBoard[i-1][j] && gameBoard[i][j].color === gameBoard[i-1][j].color) {
		        count++;
		        if (count >= 3) return true;
		      } else {
		        count = 1;
		      }
		    }
		  }
		  return false;
		}
		
		/* Function to get a new block symbol based on the color */
		function getBlockSymbol(color) {
		  switch(color) {
		    case "red": return new lib.BlockRed();
		    case "yellow": return new lib.BlockYellow();
		    case "blue": return new lib.BlockBlue();
		    case "grey": return new lib.BlockGrey();
		    // Replace white with grey
		    case "white": return new lib.BlockGrey();
		    case "black": return new lib.BlockBlack();
		    default: return new lib.BlockRed();
		  }
		}
		
		/* --- NEW: Function to get a blocker symbol based on the color --- */
		function getBlockerSymbol(color) {
		  switch(color) {
		    case "red": return new lib.BlockRedBLOCKER();
		    case "yellow": return new lib.BlockYellowBLOCKER();
		    case "blue": return new lib.BlockBlueBLOCKER();
		    case "grey": return new lib.BlockGreyBLOCKER();
		    // Replace white with grey
		    case "white": return new lib.BlockGreyBLOCKER();
		    case "black": return new lib.BlockBlackBLOCKER();
		    default: return new lib.BlockRedBLOCKER();
		  }
		}
		
		/* resizeCanvas: Adjusts the canvas resolution for high DPI displays */
		function resizeCanvas() {
		  var canvas = document.getElementById("canvas");
		  var dpr = window.devicePixelRatio || 1;
		  var logicalWidth = boardCols * cellSize;
		  var logicalHeight = boardRows * cellSize + scoreOffset;
		  var scaleFactor = Math.min(window.innerWidth / logicalWidth, window.innerHeight / logicalHeight);
		  
		  canvas.width = logicalWidth * dpr * scaleFactor;
		  canvas.height = logicalHeight * dpr * scaleFactor;
		  canvas.style.width = (logicalWidth * scaleFactor) + "px";
		  canvas.style.height = (logicalHeight * scaleFactor) + "px";
		  
		  if (stage) {
		    stage.scaleX = stage.scaleY = dpr * scaleFactor;
		    stage.update();
		  }
		}
		
		/*
		  Revised computeSlide():
		  - Splits the line into segments separated by blockers.
		  - Movable pieces slide only within their segment.
		  - When a contiguous group of 3 or more is found:
		      • For a group of 4 or more, trigger a super clear.
		        (Reward is set to 0 so the swipe callback adds exactly 3000.)
		      • Otherwise, award the normal bonus.
		*/
		function computeSlide(line) {
		  var newLine = new Array(line.length).fill(null);
		  var mapping = [];
		  var changed = false;
		  var scoreInc = 0;
		  var matchMessages = [];
		  
		  var index = 0;
		  while (index < line.length) {
		    if (line[index] && line[index].isBlocker) {
		      newLine[index] = line[index];
		      mapping.push({ origIndex: index, finalIndex: index, vanish: false, block: line[index] });
		      index++;
		      continue;
		    }
		    var segStart = index;
		    while (index < line.length && (!line[index] || (line[index] && !line[index].isBlocker))) {
		      index++;
		    }
		    var segEnd = index;
		    var movable = [];
		    for (var i = segStart; i < segEnd; i++) {
		      if (line[i] && !line[i].isBlocker) {
		         movable.push({ block: line[i], origIndex: i });
		      }
		    }
		    var pos = segStart;
		    for (var i = 0; i < movable.length; i++) {
		      if (movable[i].origIndex !== pos) {
		         changed = true;
		         mapping.push({ origIndex: movable[i].origIndex, finalIndex: pos, vanish: false, block: movable[i].block });
		      }
		      newLine[pos] = movable[i].block;
		      pos++;
		    }
		  }
		  
		  var finalMapping = [];
		  var i = 0;
		  while (i < newLine.length) {
		    if (newLine[i] == null) { 
		      i++; 
		      continue; 
		    }
		    var j = i + 1;
		    while (j < newLine.length && newLine[j] != null) { j++; }
		    var k = i;
		    while (k < j) {
		      var color = newLine[k].color;
		      var groupStart = k;
		      var groupEnd = k;
		      while (groupEnd < j && newLine[groupEnd].color === color) {
		         groupEnd++;
		      }
		      var groupLength = groupEnd - groupStart;
		      if (groupLength >= 3) {
		         changed = true;
		         var reward = 0;
		         var message = "";
		         if (groupLength >= 4) {
		           reward = 0;
		           message = "SUPER CLEAR";
		           globalClearTriggered = true;
		         } else {
		           if (color === "red" || color === "yellow" || color === "blue") {
		             reward = 50;
		           } else if (color === "grey") {
		             reward = 250;
		             message = "GREAT";
		           } else if (color === "black") {
		             reward = 1000;
		             message = "AWESOME";
		           }
		         }
		         scoreInc += reward;
		         matchMessages.push({ text: message, reward: reward });
		         for (var m = groupStart; m < groupEnd; m++) {
		            finalMapping.push({ origIndex: m, finalIndex: m, vanish: true, block: newLine[m] });
		            newLine[m] = null;
		         }
		      } else {
		         for (var m = groupStart; m < groupEnd; m++) {
		            finalMapping.push({ origIndex: m, finalIndex: m, vanish: false, block: newLine[m] });
		         }
		      }
		      k = groupEnd;
		    }
		    i = j;
		  }
		  mapping = mapping.concat(finalMapping);
		  return { mapping: mapping, newLine: newLine, scoreIncrement: scoreInc, changed: changed, matchMessages: matchMessages };
		}
		
		/* --- NEW: showMatchMessage --- */
		function showMatchMessage(obj) {
		  var displayText = "";
		  if (obj.text && obj.text !== "") {
		    displayText = obj.text + " (+" + obj.reward + ")";
		  } else {
		    displayText = "(+" + obj.reward + ")";
		  }
		  var matchText = new createjs.Text(displayText, "bold 130px Arial", "#FFF9F9");
		  matchText.textAlign = "center";
		  matchText.x = (boardCols * cellSize) / 2;
		  matchText.y = scoreText.y + scoreText.getMeasuredHeight() + 30;
		  matchText.alpha = 0;
		  stage.addChild(matchText);
		  
		  createjs.Tween.get(matchText)
		    .to({ alpha: 1, y: matchText.y - 10 }, 500, createjs.Ease.quadOut)
		    .wait(1000)
		    .to({ alpha: 0 }, 500, createjs.Ease.quadOut)
		    .call(function() {
		      stage.removeChild(matchText);
		    });
		}
		
		/* --- NEW: animateShakeEffect --- */
		function animateShakeEffect(callback) {
		  var blocks = [];
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      if (gameBoard[i][j] != null) {
		        blocks.push(gameBoard[i][j]);
		      }
		    }
		  }
		  if (blocks.length === 0) {
		    callback();
		    return;
		  }
		  var completed = 0;
		  blocks.forEach(function(block) {
		    var instance = block.instance;
		    var origX = instance.x;
		    var delay = Math.random() * 20;
		    createjs.Tween.get(instance)
		      .wait(delay)
		      .to({ x: origX + 5 }, 80, createjs.Ease.quadOut)
		      .to({ x: origX }, 100, createjs.Ease.quadIn)
		      .call(function() {
		        completed++;
		        if (completed === blocks.length) {
		          callback();
		        }
		      });
		  });
		}
		
		/* animateBoardLightUp: Staggered light-up effect */
		function animateBoardLightUp(callback) {
		  var total = playableRows * playableCols;
		  var completed = 0;
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      var x = j * cellSize;
		      var y = i * cellSize + scoreOffset;
		      var overlay = new createjs.Shape();
		      overlay.graphics.beginFill("white").drawRect(0, 0, cellSize, cellSize);
		      overlay.x = x;
		      overlay.y = y;
		      overlay.alpha = 0;
		      chessboardContainer.addChild(overlay);
		      var delay = ((i - gridMargin) * playableCols + (j - gridMargin)) * 50;
		      createjs.Tween.get(overlay)
		        .wait(delay)
		        .to({alpha: 1}, 150, createjs.Ease.quadOut)
		        .to({alpha: 0}, 150, createjs.Ease.quadOut)
		        .call(function() {
		          chessboardContainer.removeChild(this);
		          completed++;
		          if (completed === total) {
		            callback();
		          }
		        }.bind(overlay));
		    }
		  }
		}
		
		/* animateScore: Animates score change and updates high score */
		function animateScore(oldScore, newScore) {
		  var obj = { value: oldScore };
		  createjs.Tween.get(obj)
		    .to({ value: newScore }, 1000, createjs.Ease.quadOut)
		    .addEventListener("change", function() {
		      var currentValue = Math.floor(obj.value);
		      scoreText.text = "SCORE: " + currentValue;
		      if (currentValue > topScore) {
		        topScore = currentValue;
		        topScoreText.text = "HIGH SCORE: " + topScore;
		      }
		    });
		}
		
		/* isGameOver: Checks if no moves remain */
		function isGameOver() {
		  if (!boardIsFull()) return false;
		  if (possibleMatchExists()) return false;
		  return true;
		}
		
		/* handleGameOver: Animates game over sequence */
		function handleGameOver() {
		  animating = true;
		  var blocks = [];
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      if (gameBoard[i][j] != null) {
		        blocks.push(gameBoard[i][j]);
		      }
		    }
		  }
		  
		  blocks.forEach(function(block) {
		    var instance = block.instance;
		    var originalX = instance.x;
		    var originalY = instance.y;
		    stage.addChild(instance);
		    var offset = 10;
		    createjs.Tween.get(instance)
		      .to({ x: originalX + (Math.random() * offset - offset/2), y: originalY + (Math.random() * offset - offset/2) }, 40, createjs.Ease.quadOut)
		      .to({ x: originalX + (Math.random() * offset - offset/2), y: originalY + (Math.random() * offset - offset/2) }, 40, createjs.Ease.quadOut)
		      .to({ x: originalX + (Math.random() * offset - offset/2), y: originalY + (Math.random() * offset - offset/2) }, 40, createjs.Ease.quadOut)
		      .to({ x: originalX + (Math.random() * offset - offset/2), y: originalY + (Math.random() * offset - offset/2) }, 40, createjs.Ease.quadOut)
		      .to({ x: originalX, y: originalY }, 40, createjs.Ease.elasticOut)
		      .to({ scaleX: 0, scaleY: 0, alpha: 0 }, 150, createjs.Ease.quadOut)
		      .call(function() {
		        stage.removeChild(block.instance);
		      });
		  });
		  
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      gameBoard[i][j] = null;
		    }
		  }
		  
		  var oldScore = score;
		  score = 0;
		  animateScore(oldScore, 0);
		  
		  setTimeout(function() {
		    animateBoardLightUp(function() {
		      addRandomBlockAnimated(); // No swipe direction during game reset
		      animating = false;
		    });
		  }, 2000);
		}
		
		/* --- NEW: Helper to clear the entire board --- */
		function clearEntireBoard() {
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      if (gameBoard[i][j] != null) {
		         let block = gameBoard[i][j];
		         createjs.Tween.get(block.instance)
		           .to({ alpha: 0 }, 200)
		           .call(function() {
		             stage.removeChild(block.instance);
		           });
		         gameBoard[i][j] = null;
		      }
		    }
		  }
		}
		
		/*
		  --- Revised addRandomBlockAnimated ---
		  Spawns a new piece (or blocker) based on current score thresholds.
		  Blocker chance rules:
		    • Score < 500:
		  Allowed colors: [red, yellow, blue] with 0% chance (no blockers spawn).
		    • Score 500–1000:
		  Allowed colors: [red, yellow, blue] with 10% chance.
		    • Score 1001–2000:
		  Allowed colors: [red, yellow, blue, grey] with 15% chance.
		    • Score 2001–4000:
		  Allowed colors: [red, yellow, blue, grey] with 20% chance.
		    • Score 4001–10000:
		  Allowed colors: [red, yellow, blue, grey, black] with 15% chance.
		    • Score ≥ 10001:
		  Allowed colors: [red, yellow, blue, grey, black] with 25% chance.
		  
		  Additionally:
		    • If the board is completely empty (after a super clear), force a non‑blocker.
		    • If there are only 1 or 2 empty cells, NEVER spawn a blocker piece.
		    • White is replaced with grey.
		    • Black is only introduced when score reaches 4001.
		*/
		function addRandomBlockAnimated(swipeDir) {
		  var allowedColors = [];
		  var blockerChanceMapping = {};
		  if (score < 500) {
		    allowedColors = ["red", "yellow", "blue"];
		    allowedColors.forEach(function(c){ blockerChanceMapping[c] = 0; });
		  } else if (score <= 1000) {
		    allowedColors = ["red", "yellow", "blue"];
		    allowedColors.forEach(function(c){ blockerChanceMapping[c] = 0.10; });
		  } else if (score <= 2000) {
		    allowedColors = ["red", "yellow", "blue", "grey"];
		    allowedColors.forEach(function(c){ blockerChanceMapping[c] = 0.15; });
		  } else if (score <= 4000) {
		    allowedColors = ["red", "yellow", "blue", "grey"];
		    allowedColors.forEach(function(c){ blockerChanceMapping[c] = 0.20; });
		  } else if (score <= 10000) {
		    allowedColors = ["red", "yellow", "blue", "grey", "black"];
		    allowedColors.forEach(function(c){ blockerChanceMapping[c] = 0.15; });
		  } else { // Score >= 10001
		    allowedColors = ["red", "yellow", "blue", "grey", "black"];
		    allowedColors.forEach(function(c){ blockerChanceMapping[c] = 0.25; });
		  }
		  
		  var emptyCells = [];
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      if (gameBoard[i][j] == null) {
		        emptyCells.push({ i: i, j: j });
		      }
		    }
		  }
		  
		  if (swipeDir) {
		    var allowedEmptyCells = [];
		    if (swipeDir === "left") {
		      allowedEmptyCells = emptyCells.filter(cell => cell.j === gridMargin + playableCols - 1);
		    } else if (swipeDir === "right") {
		      allowedEmptyCells = emptyCells.filter(cell => cell.j === gridMargin);
		    } else if (swipeDir === "up") {
		      allowedEmptyCells = emptyCells.filter(cell => cell.i === gridMargin + playableRows - 1);
		    } else if (swipeDir === "down") {
		      allowedEmptyCells = emptyCells.filter(cell => cell.i === gridMargin);
		    }
		    if (allowedEmptyCells.length > 0) {
		      emptyCells = allowedEmptyCells;
		    }
		  }
		  
		  if (emptyCells.length === 0) {
		    return;
		  }
		  
		  // If there are 1 or 2 empty cells, NEVER spawn a blocker.
		  var forceBlocker = false;
		  if (emptyCells.length <= 2 || score < 500) {
		    forceBlocker = false;
		  }
		  
		  var cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
		  var newColor = allowedColors[Math.floor(Math.random() * allowedColors.length)];
		  
		  var chance = blockerChanceMapping[newColor] || 0;
		  var spawnBlocker;
		  // For score < 500 or very few empty cells, force no blockers.
		  if (score < 500 || emptyCells.length <= 2) {
		    spawnBlocker = false;
		  } else {
		    spawnBlocker = (Math.random() < chance);
		  }
		  
		  // NEW: If the board is completely empty, force a non‑blocker.
		  if (boardCleared()) {
		    spawnBlocker = false;
		  }
		  
		  var instance;
		  if (spawnBlocker) {
		    instance = getBlockerSymbol(newColor);
		    instance.isBlocker = true;
		  } else {
		    instance = getBlockSymbol(newColor);
		    instance.isBlocker = false;
		  }
		  
		  instance.regX = cellSize / 2;
		  instance.regY = cellSize / 2;
		  var targetX = cell.j * cellSize + cellSize / 2;
		  var targetY = cell.i * cellSize + scoreOffset + cellSize / 2;
		  instance.x = targetX;
		  instance.y = targetY;
		  instance.scaleX = 0.75;
		  instance.scaleY = 0.75;
		  instance.alpha = 0;
		  stage.addChild(instance);
		  
		  var newBlock = { color: newColor, instance: instance, row: cell.i, col: cell.j, isBlocker: instance.isBlocker };
		  gameBoard[cell.i][cell.j] = newBlock;
		  
		  createjs.Tween.get(instance).to({ scaleX: 1, scaleY: 1, alpha: 1 }, 200, createjs.Ease.quadOut);
		}
		
		/* Swipe detection event handlers */
		function handleMouseDown(evt) {
		  touchStartX = evt.stageX;
		  touchStartY = evt.stageY;
		}
		
		function handleMouseUp(evt) {
		  if (animating) return;
		  
		  if (boardIsFull() && !possibleMatchExists()) {
		    setTimeout(handleGameOver, 300);
		    return;
		  }
		  
		  touchEndX = evt.stageX;
		  touchEndY = evt.stageY;
		  
		  var dx = touchEndX - touchStartX;
		  var dy = touchEndY - touchStartY;
		  if (Math.abs(dx) < 10 && Math.abs(dy) < 10) return;
		  
		  if (Math.abs(dx) > Math.abs(dy)) {
		    if (dx > 0) swipeRightAnimated();
		    else swipeLeftAnimated();
		  } else {
		    if (dy > 0) swipeDownAnimated();
		    else swipeUpAnimated();
		  }
		}
		
		/* animateRowSwipe: Animate one row swipe (left/right) */
		function animateRowSwipe(rowIndex, direction, onLineComplete) {
		  var row = gameBoard[rowIndex];
		  var playableRow = row.slice(gridMargin, gridMargin + playableCols);
		  var isReversed = (direction === "right");
		  var arr = playableRow.slice();
		  if (isReversed) arr.reverse();
		  
		  var result = computeSlide(arr);
		  score += result.scoreIncrement;
		  var rowReward = 0;
		  if (result.matchMessages && result.matchMessages.length > 0) {
		    rowReward = result.matchMessages.reduce(function(sum, msg) {
		      return sum + msg.reward;
		    }, 0);
		  }
		  if (!result.changed) {
		    onLineComplete(false, 0);
		    return;
		  }
		  result.mapping.forEach(function(map) {
		    var block = map.block;
		    var origCol = isReversed ? ((playableCols - 1 - map.origIndex) + gridMargin) : (map.origIndex + gridMargin);
		    var finalCol = isReversed ? ((playableCols - 1 - map.finalIndex) + gridMargin) : (map.finalIndex + gridMargin);
		    var newX = finalCol * cellSize + cellSize / 2;
		    createjs.Tween.get(block.instance).to({ x: newX }, 200, createjs.Ease.quadIn).call(function() {
		      if (map.vanish) {
		        createjs.Tween.get(block.instance).to({ alpha: 0 }, 200).call(function() {
		          stage.removeChild(block.instance);
		        });
		      } else {
		        block.col = finalCol;
		      }
		    });
		  });
		  var newPlayableRow = isReversed ? result.newLine.slice().reverse() : result.newLine;
		  for (var j = 0; j < playableCols; j++) {
		    row[j + gridMargin] = newPlayableRow[j];
		  }
		  onLineComplete(true, rowReward);
		}
		
		/* animateColumnSwipe: Animate one column swipe (up/down) */
		function animateColumnSwipe(colIndex, direction, onLineComplete) {
		  var column = [];
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    column.push(gameBoard[i][colIndex]);
		  }
		  var isReversed = (direction === "down");
		  var arr = column.slice();
		  if (isReversed) arr.reverse();
		  
		  var result = computeSlide(arr);
		  score += result.scoreIncrement;
		  var colReward = 0;
		  if (result.matchMessages && result.matchMessages.length > 0) {
		    colReward = result.matchMessages.reduce(function(sum, msg) {
		      return sum + msg.reward;
		    }, 0);
		  }
		  if (!result.changed) {
		    onLineComplete(false, 0);
		    return;
		  }
		  result.mapping.forEach(function(map) {
		    var block = map.block;
		    var origRow = isReversed ? ((playableRows - 1 - map.origIndex) + gridMargin) : (map.origIndex + gridMargin);
		    var finalRow = isReversed ? ((playableRows - 1 - map.finalIndex) + gridMargin) : (map.finalIndex + gridMargin);
		    var newY = finalRow * cellSize + scoreOffset + cellSize / 2;
		    createjs.Tween.get(block.instance).to({ y: newY }, 200, createjs.Ease.quadIn).call(function() {
		      if (map.vanish) {
		        createjs.Tween.get(block.instance).to({ alpha: 0 }, 200).call(function() {
		          stage.removeChild(block.instance);
		        });
		      } else {
		        block.row = finalRow;
		      }
		    });
		  });
		  var newColumn = isReversed ? result.newLine.slice().reverse() : result.newLine;
		  for (var i = 0; i < playableRows; i++) {
		    gameBoard[i + gridMargin][colIndex] = newColumn[i];
		  }
		  onLineComplete(true, colReward);
		}
		
		/* animateHorizontalSwipe: Animate horizontal swipe with stagger */
		function animateHorizontalSwipe(direction, onComplete) {
		  var completed = 0;
		  var moveOccurred = false;
		  var totalReward = 0;
		  var playableRowIndices = [];
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    playableRowIndices.push(i);
		  }
		  playableRowIndices.forEach(function(rowIndex, idx) {
		    setTimeout(function(){
		      animateRowSwipe(rowIndex, direction, function(rowMoved, rowReward) {
		        if (rowMoved) moveOccurred = true;
		        totalReward += rowReward;
		        completed++;
		        if (completed === playableRowIndices.length) {
		          if (totalReward > 0) {
		            showMatchMessage({ text: "", reward: totalReward });
		          }
		          onComplete(moveOccurred);
		        }
		      });
		    }, idx * 10);
		  });
		}
		
		/* animateVerticalSwipe: Animate vertical swipe with stagger */
		function animateVerticalSwipe(direction, onComplete) {
		  var completed = 0;
		  var moveOccurred = false;
		  var totalReward = 0;
		  var playableColIndices = [];
		  for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		    playableColIndices.push(j);
		  }
		  playableColIndices.forEach(function(colIndex, idx) {
		    setTimeout(function(){
		      animateColumnSwipe(colIndex, direction, function(colMoved, colReward) {
		        if (colMoved) moveOccurred = true;
		        totalReward += colReward;
		        completed++;
		        if (completed === playableColIndices.length) {
		          if (totalReward > 0) {
		            showMatchMessage({ text: "", reward: totalReward });
		          }
		          onComplete(moveOccurred);
		        }
		      });
		    }, idx * 10);
		  });
		}
		
		/* animateJelloEffect: Applies a staggered "jello" effect */
		function animateJelloEffect(direction, callback) {
		  var property = (direction === "left" || direction === "right") ? "x" : "y";
		  var baseOffset = (direction === "left" || direction === "up") ? -5 : 5;
		  
		  var blocks = [];
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      if (gameBoard[i][j] != null) {
		        blocks.push({ block: gameBoard[i][j], i: i, j: j });
		      }
		    }
		  }
		  var animationsCompleted = 0;
		  var totalBlocks = blocks.length;
		  if (totalBlocks === 0) { callback(); return; }
		  
		  blocks.forEach(function(item) {
		    var block = item.block;
		    var instance = block.instance;
		    var delay = ((item.i - gridMargin) * playableCols + (item.j - gridMargin)) * 20;
		    var origVal = instance[property];
		    createjs.Tween.get(instance)
		      .wait(delay)
		      .to({ [property]: origVal + baseOffset * 0.75 }, 100, createjs.Ease.quadOut)
		      .to({ [property]: origVal - baseOffset * 0.75 }, 100, createjs.Ease.quadOut)
		      .to({ [property]: origVal + baseOffset * 1.0 }, 100, createjs.Ease.quadOut)
		      .to({ [property]: origVal - baseOffset * 1.0 }, 100, createjs.Ease.quadOut)
		      .to({ [property]: origVal + baseOffset * 1.25 }, 100, createjs.Ease.quadOut)
		      .to({ [property]: origVal }, 100, createjs.Ease.elasticOut)
		      .call(function() {
		        animationsCompleted++;
		        if (animationsCompleted === totalBlocks) {
		          callback();
		        }
		      });
		  });
		}
		
		/* Helper: Clears all blocks of a given color from the board */
		function clearColorFromBoard(color) {
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      if (gameBoard[i][j] != null && gameBoard[i][j].color === color) {
		         let block = gameBoard[i][j];
		         createjs.Tween.get(block.instance)
		           .to({ alpha: 0 }, 200)
		           .call(function() {
		             stage.removeChild(block.instance);
		           });
		         gameBoard[i][j] = null;
		      }
		    }
		  }
		}
		
		/* init: Sets up stage, board, score texts, etc. */
		function init() {
		  stage = new createjs.Stage("canvas");
		  createjs.Touch.enable(stage);
		  
		  resizeCanvas();
		  window.addEventListener("resize", resizeCanvas);
		  
		  for (var i = 0; i < boardRows; i++) {
		    gameBoard[i] = [];
		    for (var j = 0; j < boardCols; j++) {
		      gameBoard[i][j] = null;
		    }
		  }
		  
		  scoreText = new createjs.Text("SCORE: 0", "bold 96px Arial", "#FFF9F9");
		  scoreText.textAlign = "center";
		  scoreText.x = (boardCols * cellSize) / 2;
		  scoreText.y = 20;
		  stage.addChild(scoreText);
		  
		  topScoreText = new createjs.Text("HIGH SCORE: " + topScore, "bold 48px Arial", "#92D692");
		  topScoreText.textAlign = "center";
		  topScoreText.x = (boardCols * cellSize) / 2;
		  topScoreText.y = boardRows * cellSize + scoreOffset - 230;
		  stage.addChild(topScoreText);
		  
		  drawBoardBackground();
		  drawChessboard();
		  
		  stage.on("stagemousedown", handleMouseDown);
		  stage.on("stagemouseup", handleMouseUp);
		  
		  animateBoardLightUp(function() {
		    addRandomBlockAnimated();
		  });
		  
		  createjs.Ticker.framerate = 30;
		  createjs.Ticker.addEventListener("tick", function(evt) {
		    stage.update();
		    applyBayer8x8_32color();
		  });
		}
		
		/* drawBoardBackground: Draws background behind playable area */
		function drawBoardBackground() {
		  var bg = new createjs.Shape();
		  var x = gridMargin * cellSize;
		  var y = gridMargin * cellSize + scoreOffset;
		  var width = playableCols * cellSize;
		  var height = playableRows * cellSize;
		  var cornerRadius = 60;
		  bg.graphics.beginFill("#7B7B7B").drawRoundRect(0, 0, width, height, cornerRadius);
		  bg.x = x;
		  bg.y = y;
		  stage.addChildAt(bg, 0);
		}
		
		/* drawChessboard: Draws the chessboard pattern */
		function drawChessboard() {
		  var boardContainer = new createjs.Container();
		  chessboardContainer = boardContainer;
		  
		  for (var i = gridMargin; i < gridMargin + playableRows; i++) {
		    for (var j = gridMargin; j < gridMargin + playableCols; j++) {
		      var square = new createjs.Shape();
		      var isEven = ((i + j) % 2 === 0);
		      var fillColor = isEven ? "#707070" : "#7B7B7B";
		      square.graphics.beginFill(fillColor).drawRect(0, 0, cellSize, cellSize);
		      square.x = j * cellSize;
		      square.y = i * cellSize + scoreOffset;
		      boardContainer.addChild(square);
		      
		      var overlay = new createjs.Shape();
		      overlay.graphics.beginFill("white").drawRect(0, 0, cellSize, cellSize);
		      overlay.x = square.x;
		      overlay.y = square.y;
		      overlay.alpha = 0;
		      boardContainer.addChild(overlay);
		      
		      var delay = ((i - gridMargin) * playableCols + (j - gridMargin)) * 50;
		      createjs.Tween.get(overlay)
		        .wait(delay)
		        .to({alpha: 1}, 150, createjs.Ease.quadOut)
		        .to({alpha: 0}, 150, createjs.Ease.quadOut);
		    }
		  }
		  var maskShape = new createjs.Shape();
		  var maskX = gridMargin * cellSize;
		  var maskY = gridMargin * cellSize + scoreOffset;
		  var maskWidth = playableCols * cellSize;
		  var maskHeight = playableRows * cellSize;
		  var cornerRadius = 60;
		  maskShape.graphics.beginFill("black").drawRoundRect(0, 0, maskWidth, maskHeight, cornerRadius);
		  maskShape.x = maskX;
		  maskShape.y = maskY;
		  boardContainer.mask = maskShape;
		  
		  stage.addChildAt(boardContainer, 1);
		}
		
		/* Swipe functions */
		function swipeLeftAnimated() {
		  if (animating) return;
		  animating = true;
		  var oldScore = score;
		  animateHorizontalSwipe("left", function(moved) {
		    if (!moved) {
		      animateShakeEffect(function(){
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      });
		      return;
		    }
		    setTimeout(function() {
		      if (globalClearTriggered) {
		        score += 1000;
		        showMatchMessage({ text: "SUPER CLEAR", reward: 3000 });
		        clearEntireBoard();
		        globalClearTriggered = false;
		        animateBoardLightUp(function() {
		          addRandomBlockAnimated("left");
		          animateScore(oldScore, score);
		          if (boardIsFull() && !possibleMatchExists()) {
		            handleGameOver();
		          } else {
		            animating = false;
		          }
		        });
		      } else if (boardCleared()) {
		        score += 500;
		        showMatchMessage({ text: "", reward: 500 });
		        addRandomBlockAnimated("left");
		        animateScore(oldScore, score);
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      } else {
		        clearColors.forEach(function(color) {
		          clearColorFromBoard(color);
		        });
		        clearColors = [];
		        addRandomBlockAnimated("left");
		        animateScore(oldScore, score);
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      }
		    }, 300);
		  });
		}
		
		function swipeRightAnimated() {
		  if (animating) return;
		  animating = true;
		  var oldScore = score;
		  animateHorizontalSwipe("right", function(moved) {
		    if (!moved) {
		      animateShakeEffect(function(){
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      });
		      return;
		    }
		    setTimeout(function() {
		      if (globalClearTriggered) {
		        score += 3000;
		        showMatchMessage({ text: "SUPER CLEAR", reward: 3000 });
		        clearEntireBoard();
		        globalClearTriggered = false;
		        animateBoardLightUp(function() {
		          addRandomBlockAnimated("right");
		          animateScore(oldScore, score);
		          if (boardIsFull() && !possibleMatchExists()) {
		            handleGameOver();
		          } else {
		            animating = false;
		          }
		        });
		      } else if (boardCleared()) {
		        score += 500;
		        showMatchMessage({ text: "", reward: 500 });
		        addRandomBlockAnimated("right");
		        animateScore(oldScore, score);
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      } else {
		        clearColors.forEach(function(color) {
		          clearColorFromBoard(color);
		        });
		        clearColors = [];
		        addRandomBlockAnimated("right");
		        animateScore(oldScore, score);
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      }
		    }, 300);
		  });
		}
		
		function swipeUpAnimated() {
		  if (animating) return;
		  animating = true;
		  var oldScore = score;
		  animateVerticalSwipe("up", function(moved) {
		    if (!moved) {
		      animateShakeEffect(function(){
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      });
		      return;
		    }
		    setTimeout(function() {
		      if (globalClearTriggered) {
		        score += 3000;
		        showMatchMessage({ text: "SUPER CLEAR", reward: 3000 });
		        clearEntireBoard();
		        globalClearTriggered = false;
		        animateBoardLightUp(function() {
		          addRandomBlockAnimated("up");
		          animateScore(oldScore, score);
		          if (boardIsFull() && !possibleMatchExists()) {
		            handleGameOver();
		          } else {
		            animating = false;
		          }
		        });
		      } else if (boardCleared()) {
		        score += 500;
		        showMatchMessage({ text: "", reward: 500 });
		        addRandomBlockAnimated("up");
		        animateScore(oldScore, score);
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      } else {
		        clearColors.forEach(function(color) {
		          clearColorFromBoard(color);
		        });
		        clearColors = [];
		        addRandomBlockAnimated("up");
		        animateScore(oldScore, score);
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      }
		    }, 300);
		  });
		}
		
		function swipeDownAnimated() {
		  if (animating) return;
		  animating = true;
		  var oldScore = score;
		  animateVerticalSwipe("down", function(moved) {
		    if (!moved) {
		      animateShakeEffect(function(){
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      });
		      return;
		    }
		    setTimeout(function() {
		      if (globalClearTriggered) {
		        score += 3000;
		        showMatchMessage({ text: "SUPER CLEAR", reward: 3000 });
		        clearEntireBoard();
		        globalClearTriggered = false;
		        animateBoardLightUp(function() {
		          addRandomBlockAnimated("down");
		          animateScore(oldScore, score);
		          if (boardIsFull() && !possibleMatchExists()) {
		            handleGameOver();
		          } else {
		            animating = false;
		          }
		        });
		      } else if (boardCleared()) {
		        score += 500;
		        showMatchMessage({ text: "", reward: 500 });
		        addRandomBlockAnimated("down");
		        animateScore(oldScore, score);
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      } else {
		        clearColors.forEach(function(color) {
		          clearColorFromBoard(color);
		        });
		        clearColors = [];
		        addRandomBlockAnimated("down");
		        animateScore(oldScore, score);
		        if (boardIsFull() && !possibleMatchExists()) {
		          handleGameOver();
		        } else {
		          animating = false;
		        }
		      }
		    }, 300);
		  });
		}
		
		/* Start the game */
		init();
	}

	// actions tween:
	this.timeline.addTween(cjs.Tween.get(this).call(this.frame_0).wait(1));

	// Layer_9
	this.dithering = new lib.dithering();
	this.dithering.name = "dithering";
	this.dithering.setTransform(-4480.65,-447.45);
	this.dithering.compositeOperation = "difference";

	this.timeline.addTween(cjs.Tween.get(this.dithering).wait(1));

	// BlockBlue
	this.BlockBlackBLOCKER = new lib.BlockBlackBLOCKER();
	this.BlockBlackBLOCKER.name = "BlockBlackBLOCKER";
	this.BlockBlackBLOCKER.setTransform(2098.65,1183.1,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.BlockGreyBLOCKER = new lib.BlockGreyBLOCKER();
	this.BlockGreyBLOCKER.name = "BlockGreyBLOCKER";
	this.BlockGreyBLOCKER.setTransform(2098.65,869.15,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.BlockYellowBLOCKER = new lib.BlockYellowBLOCKER();
	this.BlockYellowBLOCKER.name = "BlockYellowBLOCKER";
	this.BlockYellowBLOCKER.setTransform(2098.65,577.3,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.BlockRedBLOCKER = new lib.BlockRedBLOCKER();
	this.BlockRedBLOCKER.name = "BlockRedBLOCKER";
	this.BlockRedBLOCKER.setTransform(2098.65,294.9,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.BlockBlueBLOCKER = new lib.BlockBlueBLOCKER();
	this.BlockBlueBLOCKER.name = "BlockBlueBLOCKER";
	this.BlockBlueBLOCKER.setTransform(2098.65,-0.1,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.BlockBlack = new lib.BlockBlack();
	this.BlockBlack.name = "BlockBlack";
	this.BlockBlack.setTransform(-354.75,1183.1,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.BlockGrey = new lib.BlockGrey();
	this.BlockGrey.name = "BlockGrey";
	this.BlockGrey.setTransform(-354.75,869.15,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.BlockYellow = new lib.BlockYellow();
	this.BlockYellow.name = "BlockYellow";
	this.BlockYellow.setTransform(-354.75,577.3,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.BlockRed = new lib.BlockRed();
	this.BlockRed.name = "BlockRed";
	this.BlockRed.setTransform(-354.75,294.9,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.BlockBlue = new lib.BlockBlue();
	this.BlockBlue.name = "BlockBlue";
	this.BlockBlue.setTransform(-354.75,-0.1,0.8521,0.8521,0,0,0,0.1,-0.1);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.BlockBlue},{t:this.BlockRed},{t:this.BlockYellow},{t:this.BlockGrey},{t:this.BlockBlack},{t:this.BlockBlueBLOCKER},{t:this.BlockRedBLOCKER},{t:this.BlockYellowBLOCKER},{t:this.BlockGreyBLOCKER},{t:this.BlockBlackBLOCKER}]}).wait(1));

	// stageBackground
	this.shape = new cjs.Shape();
	this.shape.graphics.f().s("rgba(0,0,0,0)").ss(1,1,1,3,true).p("EidzidzME7nAAAMAAAE7nMk7nAAAg");
	this.shape.setTransform(1000,1000);

	this.shape_1 = new cjs.Shape();
	this.shape_1.graphics.f("#171A17").s().p("EidzCd0MAAAk7nME7nAAAMAAAE7ng");
	this.shape_1.setTransform(1000,1000);

	this.timeline.addTween(cjs.Tween.get({}).to({state:[{t:this.shape_1},{t:this.shape}]}).wait(1));

	this._renderFirstFrame();

}).prototype = p = new lib.AnMovieClip();
p.nominalBounds = new cjs.Rectangle(-3480.6,552.6,5845.1,2749);
// library properties:
lib.properties = {
	id: 'CCC7978293DA4B51966DE65DAFBFF694',
	width: 2000,
	height: 2000,
	fps: 30,
	color: "#171A17",
	opacity: 1.00,
	manifest: [
		{src:"images/swipe3_atlas_1.png?1743802823458", id:"swipe3_atlas_1"}
	],
	preloads: []
};



// bootstrap callback support:

(lib.Stage = function(canvas) {
	createjs.Stage.call(this, canvas);
}).prototype = p = new createjs.Stage();

p.setAutoPlay = function(autoPlay) {
	this.tickEnabled = autoPlay;
}
p.play = function() { this.tickEnabled = true; this.getChildAt(0).gotoAndPlay(this.getTimelinePosition()) }
p.stop = function(ms) { if(ms) this.seek(ms); this.tickEnabled = false; }
p.seek = function(ms) { this.tickEnabled = true; this.getChildAt(0).gotoAndStop(lib.properties.fps * ms / 1000); }
p.getDuration = function() { return this.getChildAt(0).totalFrames / lib.properties.fps * 1000; }

p.getTimelinePosition = function() { return this.getChildAt(0).currentFrame / lib.properties.fps * 1000; }

an.bootcompsLoaded = an.bootcompsLoaded || [];
if(!an.bootstrapListeners) {
	an.bootstrapListeners=[];
}

an.bootstrapCallback=function(fnCallback) {
	an.bootstrapListeners.push(fnCallback);
	if(an.bootcompsLoaded.length > 0) {
		for(var i=0; i<an.bootcompsLoaded.length; ++i) {
			fnCallback(an.bootcompsLoaded[i]);
		}
	}
};

an.compositions = an.compositions || {};
an.compositions['CCC7978293DA4B51966DE65DAFBFF694'] = {
	getStage: function() { return exportRoot.stage; },
	getLibrary: function() { return lib; },
	getSpriteSheet: function() { return ss; },
	getImages: function() { return img; }
};

an.compositionLoaded = function(id) {
	an.bootcompsLoaded.push(id);
	for(var j=0; j<an.bootstrapListeners.length; j++) {
		an.bootstrapListeners[j](id);
	}
}

an.getComposition = function(id) {
	return an.compositions[id];
}


an.makeResponsive = function(isResp, respDim, isScale, scaleType, domContainers) {		
	var lastW, lastH, lastS=1;		
	window.addEventListener('resize', resizeCanvas);		
	resizeCanvas();		
	function resizeCanvas() {			
		var w = lib.properties.width, h = lib.properties.height;			
		var iw = window.innerWidth, ih=window.innerHeight;			
		var pRatio = window.devicePixelRatio || 1, xRatio=iw/w, yRatio=ih/h, sRatio=1;			
		if(isResp) {                
			if((respDim=='width'&&lastW==iw) || (respDim=='height'&&lastH==ih)) {                    
				sRatio = lastS;                
			}				
			else if(!isScale) {					
				if(iw<w || ih<h)						
					sRatio = Math.min(xRatio, yRatio);				
			}				
			else if(scaleType==1) {					
				sRatio = Math.min(xRatio, yRatio);				
			}				
			else if(scaleType==2) {					
				sRatio = Math.max(xRatio, yRatio);				
			}			
		}
		domContainers[0].width = w * pRatio * sRatio;			
		domContainers[0].height = h * pRatio * sRatio;
		domContainers.forEach(function(container) {				
			container.style.width = w * sRatio + 'px';				
			container.style.height = h * sRatio + 'px';			
		});
		stage.scaleX = pRatio*sRatio;			
		stage.scaleY = pRatio*sRatio;
		lastW = iw; lastH = ih; lastS = sRatio;            
		stage.tickOnUpdate = false;            
		stage.update();            
		stage.tickOnUpdate = true;		
	}
}
an.handleSoundStreamOnTick = function(event) {
	if(!event.paused){
		var stageChild = stage.getChildAt(0);
		if(!stageChild.paused || stageChild.ignorePause){
			stageChild.syncStreamSounds();
		}
	}
}
an.handleFilterCache = function(event) {
	if(!event.paused){
		var target = event.target;
		if(target){
			if(target.filterCacheList){
				for(var index = 0; index < target.filterCacheList.length ; index++){
					var cacheInst = target.filterCacheList[index];
					if((cacheInst.startFrame <= target.currentFrame) && (target.currentFrame <= cacheInst.endFrame)){
						cacheInst.instance.cache(cacheInst.x, cacheInst.y, cacheInst.w, cacheInst.h);
					}
				}
			}
		}
	}
}


})(createjs = createjs||{}, AdobeAn = AdobeAn||{});
var createjs, AdobeAn;